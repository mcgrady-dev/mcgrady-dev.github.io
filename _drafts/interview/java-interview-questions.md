## 基本原理（Fundamentals）

### 基本语法（Basic Syntax）

1. **`private` `protected` `public`关键字的用法区别？**

   - `private`：私有访问权限；
   - `protected`：继承访问权限；
   - `public`：公开访问权限；

2. **`static`关键字的作用？**

   用于修饰类、方法、字段、代码块，适用于生命周期较长的对象，同时该对象实例被多个其他对象共享的场景。

3. **`==`和`equals()`和`hashCode()`的区别？**

   - `==`：对于基本类型比较的是他们的值，对于引用类型比较的是他们在内存中存放的地址；
   - `equals()`：默认继承自Obejct#eqluas()，对于基本类型的包装类和String用于判断他们值是否相等，引用类型用于判断对象的引用地址是否为同一个对象；
   - `hashCode()`：默认继承自`Object#hashCode()`，返回对象存储的物理地址（哈希码）；

4. **`final`、`finally`和`finalize`的区别？**

   - `final`关键字用于修饰字段、方法、类；
   - `finally`是try/catch语句中附带的语句块，不管有没抛出异常最终会被执行；
   - `finalize`是Object里定义的方法，当该方法被重写，在GC回收该对象时被执行；

5. **`wait`与`notify`、`notifyAll`的区别？**
   `wait()` `notify()` `notfiyAll()`配合`synchronized`关键字来完成线程间的调度。

   - `wait()`使持有该对象的线程进入休眠状态，同时释放掉当前的对象锁（在调用方法之前线程必须先获得该对象的对象锁）；
   - `notify()`通知等待该对象的线程唤醒，继续运行；
   - `notifyAll()`通知等待所有等待该对象的线程唤醒，继续运行；

6. **`synchronized`关键字的用法、作用及实现原理？**

   - 用法：
     - `synchronized`同步代码块，作用于调用代码的对象实例；
     - `synchronized`同步方法，作用于调用该方法的对象，等同于`synchronized(this);`
     - `synchronized`静态同步方法，作用于该类的所有对象实例，等同于`synchronized(class)`;
   - 作用：使用`synchronized`同步锁可以在并发编程中有效的避免线程安全问题，譬如：多个线程并发访问共享数据时，通过`synchronized`以保证共享数据在同一时刻只被一条线程执行；
   - 实现原理：`synchronized`修饰的块结构经过编译后，分别形成`monitorenter`和`monitorexit`两条字节码指令，JVM通过这两条指令来控制锁的获取和释放；

7. **`synchronized(this)`与`synchronized(object)`锁住的是什么？**
   锁定当前类的对象实例，当`synchronized`代码块内容执行完成或过程中抛出异常，自动释放锁，即同一时刻多个线程访问该对象，则会被阻塞。

8. **JDK 1.6之后对synchronized做了哪些优化？**
   JDK 1.6对锁的实现引入了如：偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等优化，以减少所操作带来的开销。

9. **`volatile` 关键字的用法、作用及实现原理？**

   - 用法：`volatile`只能作用于属性
   - 作用：`volatile`是JVM供的轻量级同步锁机制，以保证此变量在线程间的可见性，及禁止指令重排优化；
   - 实现原理：`volatile`通过**对一个变量的写操作先行发生于后面对这个变量的读操作**——变量规则，保证了新值能立即同步到主存，以及每次使用前立即从主存刷新，因此保证了多线程操作时变量的可见性；

10. **`synchronized`与`volatile` 之间的区别？**

    - `volatile`的同步机制性能优于`synchronized；`
    - `volatile`只能修饰属性，而`synchronized`可以修饰修饰方法和代码块；
    - `volatile`能保证数据的可见性，但不能保证数据的原子性，`synchronized`则两者都能兼顾；
    - `volatile`主要用于解决变量在多个线程之间的可见性，而`synchronized`主要解决的是多个线程之间访问共享资源的同步性；
    - 多线程访问`volatile`属性并不会发生阻塞，而访问`synchronized`可能发生阻塞；
    - `volatile`修饰的属性会禁止指令重排优化，而`synchronized`可能会被编译器优化；

11. **`synchronized`与`ReentrantLock`之间的差别？**

    - `synchronized`是关键字，依赖于JVM实现，而`ReentrantLock`是Java类，依赖于JDK API实现；
    - `synchronized`无法判断是否获取锁状态，而`ReentrantLock`可以判断是否获取到锁；
    - `synchronized`会自动释放锁，而`ReentrantLock`需在`finally`中手动释放锁，否则容易造成死锁；
    - `ReentrantLock`在多个条件变量和高度竞争锁的地方比`synchronized`更适合
    
12. **`transient`关键字的用法、作用及实现原理？**

    - 用法：仅能修饰属性，前提要实现`Serializable`接口，局部变量不能被`transient`修饰，静态属性无论是否被`transient`修饰均不能被序列化；

    - 作用：通过`transient`修饰的属性将不再是对象持久化的一部分，该属性内容在序列化后无法获取；
    - 实现原理：通过JVM中类或接口的字段表中的`ACC_TRANSIENT`进行标记，在序列化过程中忽略声明`ACC_TRANSIENT`标记的属性。

### 1.2 数据类型、变量（DataTypes, Variables）

1. **`Integer`和`int` 之间的区别？**

   - `int`是基本数据类型，`Integer`是int的包装类；
   - `Integer`需实例化后才能使用，默认值是`null`，`int`默认值是0；

2. **自动装箱、拆箱的实现原理？类型转换实现原理？**

   - 自动装箱调用的是包装类的`valueOf()`方法创建一个包装类对象并赋值；
   - 自动拆箱调用的是包装类的`xxxValue()`方法返回指定的基础类型字面量；

3. **自动装箱发生在什么时候？编译期还是运行期？**
   基本类型与包装类型进行运算或赋值时，Java在编译期将它们进行互相转换。

4. **说说对String的了解？String为什么要设计成`final`？**

   String属于引用数据类型，被`final`修饰，含有不可变性，字符串对象通过`char`/`byte`数组接收，存储在常量池中，String被设计为`final`主要有几个考虑：

   - 状态不可变的对象，不需要任何加锁操作保证线程安全，可以提高系统性能；
   - 复用已存在常量池中的字符串对象，避免重复创建；
   - 保证String对象的哈希码的唯一性，尤其在Map等容器中以String为Key频繁使用时，不必每次都去计算新的哈希值，避免不必要的开销；

5. **`String`、`StringBuffer`、`StringBuilder`之间的区别？**
   String用于存储和操作字符串，`StringBuilder`是字符串缓冲区，用于字符串操作，`StringBuffer`与`StringBuilder`类似，不同之处是`StringBuffer`属于可变类，对方法加了同步锁，保证线程安全。

### 1.3 条件语句（Conditionals）



### 1.4 方法（Functions）



### 1.5 数据结构（DataStructures）

1. **Java的数据结构有哪些？**
   - 线性集合：数组（数组）、链表（Linked List）、队列（Queue）、栈（Stack）
   - 映射集合（Map）、堆（Heap）、树（Tree）、图（Graph）

### 1.6 面向对象、接口、类（OOP, Interfaces, Classes）

1. **什么是面向过程（PO）？**

   面向过程会把系统拆分成若干个过程（函数和数据），按一定的顺序执行这些过程。

2. **什么是面向对象（OOP）？**

   - 面向对象是一种对现实世界理解和抽象的方法，即把数据及对数据的操作作为一个整体来看待（对象），对具有共同特征的对象归纳成类，同时运用封装、继承、多态等机制来构造模拟现实系统的方法；
   - 把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个对象在整体解决问题的步骤中的某种行为；

3. **什么是类？什么是对象？类和对象之间的关系是什么？**

   - 类是一个模版，描述了一类对象的行为和状态；
   - 对象是类的实例，有状态和行为；

   或

   - 类是对象的集合，是抽象的，对象是类的实例化，是具体的；

4. **什么是多态？实现多态的机制是什么？**
   多态是指在基类或接口中定义的属性或方法被子类继承后，可以具有不同的数据类型或表现形式。
   动态绑定是实现多态性的重要因素，动态绑定是指在运行期间根据引用对象的实际类型调用相应的方法。

5. **`Interface` 与`Abstract Class` 的区别？**

   - 接口是行为的抽象，抽象类是对类包含共性的属性和行为进行抽象；
   - 当关注一个事物的本质时，使用抽象类，当关注一个或一组操作时，使用接口；
   - 接口强调行为或功能，抽象类抢到所属关系；
   - （单继承，多实现）类可以实现多个接口，但抽象类只能继承一个；
   - 接口中所有属性为`public static final`公开不可变的，方法默认为`public abstract`公开抽象的，抽象类和普通类差不多，可以有抽象方法和属性；

6. **重写`Override` 与重载 `Overload` 的区别？**

   - 重写表示子类覆盖父类中同名和参数相同的方法，以实现特定于子类的行为，重载表示类中可以有多个同名的方法（不限定参数）；
   - 重写是父类与子类之间多态性的一种表现，重载是类中多态性的表现；

7. **静态属性和静态方法是否可以被继承？是否可以被重写？为什么？**

   - 静态属性和静态方法不属于任何类的实例，在编译期间绑定在类上，所以不具备多态性；
   - 当子类调用父类的静态属性或方法时，实际上是隐式指向了父类的静态属性和方法，可以称为继承；
   - 重写的本质动态绑定，而静态属性和方法则在编译期间就确定了，当子类重写父类的静态属性和方法时，实际上是在子类的命名空间为与父类同名静态属性和方法重新分配了一块内存空间，所以不可以被重写；

8. **什么是内部类？成员内部类、静态内部类、局部内部类和匿名内部类的区别以及作用？**

   - Java中允许一个类被定义在另一类中，这样的类叫嵌套类，对嵌套类的定义分为两种：静态嵌套类（即静态内部类）和非静态嵌套类（即内部类）；
   - 内部类又分为：成员内部类、匿名内部类、局部内部类，并持有一个外部类的隐式引用；
   - 成员内部类，作为外部类对象的成员，并拥有其外部类所有成员的访问权；
   - 局部内部类是在方法体内声明的内部类，不能有访问说明符，与成员内部类的区别在于局部内部类的访问仅限于方法内或该作用域内；
   - 匿名内部类是没有类名，没有构造器函数的内部类，创建类时不必为类进行命名；
   - 静态内部类是`static`修饰的成员内部类，只能访问外部类的静态成员变量和方法，不持有外部类的引用；
   - 作用：
     - 封装性：对类的访问权限做出一定的限制，把一些逻辑关系组织在一起，对外界隐藏；
     - 多继承：通过内部类可以实现多个继承；
     - 回调功能：以接口作为函数的入参 ，方法内使用接口进行回调，调用方法处通过匿名内部类实现接口的回调；
     - 访问不在同一包名下类的`protected`方法：声明匿名内部类创建额外的方法通过`super`调用父类`protected`方法；

9. **静态内部类、内部类、匿名内部类，为什么内部类会持有外部类的引用？持有的引用是this还是其它？**
   因为内部类定义在外部类中，在内部类的构造函数编译器会隐式传入外部类的实例，然通过`this$0`访问外部类的成员。

10. **简单介绍下泛型，以及泛型擦除相关的概念？**

    - 泛型的本质是参数化多台的应用，将操作的数据类型指定为方法签名中的一种特殊参数，这种参数能够在类、接口和方法中创建；
    - 泛型擦除是指源码中的泛型数据类型在编译后被替换成裸类型，在运行期间访问元素的地方自动插入一些强制类型转换底代码；

11. **泛型 `<? super T>` 与 `<? extends T>`的区别？**

    - `<? extends T>`表示上界通配符，可以传递`T`及父类的类型；

    - `<? super T>`表示下界通配符，可以传递`T`及子类的类型；



## 深入理解（Getting Deeper）

### 集合框架（Collection Framework）

1. **列举Java集合之间的继承关系？**

   ```mermaid
   flowchart BT
       
       List & Queue & Set --> Collection
   
       ArrayList & LinkedList -.-> List
   
       LinkedList -.-> Queue
   
       HashSet & LinkedHashSet & TreeSet -.-> Set 
   
       HashMap & HashTable & TreeMap --> Map
       
       LinkedHashMap --> HashMap
   ```

2. **`List`、`Set`、`Map`的区别？**

   - List是有序的线性集合，可以动态增长，查找元素效率高，插入删除效率低，因为会引起其他元素位置改变；
   - Set是无序的集合，元素的位置由该元素的HashCode决定，不允许重复的元素，查找元素效率低，删除插入效率高；
   - Map是键值对集合，键和值对象之间存在一种对应的映射关系，Key是唯一的，通过Key可以找到指定的Value；

3. **`ArrayList`和`LinkedList`的区别和适用场景？**

   - ArrayList和LinkedList都实现自List接口，但ArrayList基于动态数组实现，LinkedList基于双向链表结构实现；
   - 随机索引访问元素效率上ArrayList更优，因为根据寻址公式进行定位，简单高效；
   - 对于频繁向集合中间插入或删除元素效率上LinkedList更优，因为ArrayList需要改变其他元素位置；
   - 内存占用方面，LinkedList占用内存更大，因为Node节点除了存储数据，还存储了前后引用的值，而ArrayList在尾部预留一定的容量空间，有一定的空间浪费的情况；

4. **`ArrayList`和`LinkedList`怎么动态扩容的？**

   - ArrayList通过无参构造实例化时，初始容量为0，当第一次添加元素时初始化容量为10，后续每次添加元素按1.5倍的比例通过`Arrays.copyOf()`把源数组复制到另一个内存空间更大的数组来实现扩容；
   - LinkedList基于双向链表实现，没有初始化大小，通过改变插入位置节点的前后指针来添加元素，且LinkedList属于离散空间，所以不需要主动扩容；

5. **`HashMap`、`HashTable`和`ConcurrentHashMap`的实现原理和区别？** 

   - HashMap、HashTable、ConcurrentHashMap底层都是通过数组+链表/红黑树实现；
   - HashMap允许使用`null`值和`null`键，非线程安全；
   - HashTable不允许使用`null`的键值，使用`synchronized`实现线程安全；
   - ConcurrentHashMap使用了乐观锁+`synchronized`实现线程安全；

6. **`HashMap`如何解决散列碰撞？**
   拉链法、二次hash（与运算）、加载因子控制动态扩容临界值。

7. **谈谈对`LinkedHashMap`的了解？**
   LinkedHashMap继承自HashMap，在原来的基础上实现了双向链表来遍历所有Entry，因此LinkedHashMap内存占用相比HashMap要多，LinkedHashMap很重要的特点是支持按照插入顺序或访问顺序来访问所有的Entry。

8. **SparseArray 的实现原理？**
   
   - 实现原理：通过`int`和`Object`类型的数组分别存储`key`和`value`，通过二分查找法搜索元素，插入元素触发gc时会移动元素，扩容时当前长度小于等4扩容至8，否则以当前长度的2倍扩容，扩容通过数组拷贝实现；
   - 优缺点：相较于HashMap，SparseArray在存储单个键值对时更省内存，同时使用int类型数组作为key的集合，避免了int到Integer自动装箱的消耗，由于查找是需要进行二分查找，元素较多（1000）时效率低；



### 2.2 内存管理（Memory Management）

1. **简述JVM内存模型和内存区域？**

   - 内存区域通常指JVM运行时数据区；
     <img src="https://s2.loli.net/2022/09/13/IqjLFxn4Sz7VeXK.png" style="zoom:80%;" />
   - 内存模型是一种虚拟机规范，定义了JVM在计算机内存（RAM）中工作方式，屏蔽了各种硬件和操作系统的内存访问差异，以实现Java跨平台的能力；

2. **`String a = "a"+"b"+"c"` 在内存中创建几个对象？**
   1个，在Javac编译器中会进行常量折叠优化，全字面量字符串相加是可以折叠为一个字面常量。

3. **UTF-8编码中的中文占几个字节？一个字节占多少个二进制位？**

   | 类型     | 字节 | 二进制位 |
   | -------- | ---- | -------- |
   | 数字     | 1    | 8        |
   | 英文字母 | 1    | 8        |
   | 汉字     | 4    | 32       |

   

### JVM

1. **Java中对象的创建过程？**
   当虚拟机遇到一条`new`字节码指令时会执行以下步骤来创建对象：

   ```mermaid
   flowchart LR
   	类加载检查 --> 分配内存空间 --> 初始化零值 --> 设置对象头 --> 执行init方法
   ```

2. **对象在虚拟机中是如何布局的？**
   对象在堆内存中存储布局可以划分为三个部分：

   - 对象头：主要包含用于存储对象自身的运行时数据，和指向类型元数据的指针（用于定位归属于哪个类实例）；
   - 实例数据：用于存储对象的实例值
   - 对齐填充：非必然存在，作为占位符的作用，以适应虚拟机自动内存管理系统的要求（对象起始地址必须是8字节的整数倍）；

3. **对象的访问和定位？**
   Java中对象的访问通过栈上的`reference`数据来操作堆上的具体对象，对象的访问方式由虚拟机实现而定，主流的访问方式有：

   - 句柄访问：Java堆中会划分出一块内存来作为句柄池，reference中存储是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的指针地址，特点是：reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference不需要修改；
   - 直接指针访问：reference中存储的就是对象地址；

4. **类加载的过程？**

   ```mermaid
   flowchart LR
       subgraph Linking ["连接(Linking)"]
           direction LR
           V("验证<br>Verification") --> P("准备<br>Preparation") --> R("解析<br>Resolution")
       end
       Loading("加载<br>Loading") --> Linking --> I("初始化<br>Initialization")
   ```

5. **对ClassLoader机制的了解？类什么时候会被加载？**

   - ClassLoader负责将Class字节码解析成JVM统一要求的对象格式，然后加载到JVM内存中，并审查每个类由谁加载（父优先级的等级加载机制）
   - 类加载的时机：
     - 当遇到`new`、`getstatic`、`putstatic`等指令时
     - 对类进行反射调用时
     - 初始化某个类的子类时
     - 虚拟机启动时会先加载设置的程序主类

6. **Android中ClassLoader和Java中有什么关系和区别？**
    Android中的ClassLoader同样负责加载class文件到内存中，但在加载细节上会有差别，Android打包时会将class文件打包成一个或多个dex文件，当安装应用时，会对不同平台的dex通过`dex2opt`工具进行优化，该过程会生成一个`odex`文件，用于提高执行效率。

7. **Class文件的组成？常量池里面有什么内容？**

  - Class文件由：魔法值、Class文件版本、常量池、访问标志、类索引、接口索引集合、字段表集合、方法表集合、属性表集合组成。
  - 常量池主要存放两大类常量：字面量（字符串、final修饰的常量值）、符号引用



### Garbage Collection

1. **对垃圾回收机制（GC）的了解？**
   对系统运行过程中产生的一些无用的对象进行回收，回收的是堆区和方法区的内存。

2. **垃圾回收机制与调用 `System.gc()` 的区别？**
   `System.gc()`底层调用的是`Runtime.getRuntime().gc()`，作用只是提醒虚拟机希望进行一次垃圾回收，会触发Full GC，但不能保证垃圾回收一定执行，具体取决于虚拟机实例和不同的回收策略。

3. **垃圾回收算法？**
   根据分代收集理论，Java堆被划分出不同的区域，将不同年龄的对象分配到不同的区域中存储，然后针对不同区域对象的存亡特征选择相匹配的垃圾收集算法：

   - 标记-清除算法：标记所有需要回收的对象，然后统一回收被标记的对象，主要缺点：大量标记和清楚动作、内存空间碎片化；
   - 标记-复制算法：将可用内存划分为大小相等的块，每次只使用其中一块，用完则将还存活的对象复制到另外一块上面，然后将使用过的内存空间一次清理掉，主要缺点：大量的内存间复制开销、内存缩小为原来的一半；
   - 标记-整理算法：标记存活的对象，统一向内存空间一端移动，然后清理掉边界以外的内存，主要缺点：大量移动存活对象、必须全程暂停用户程序才能进行；

4. **HotSpot为什么要分为新生代和老年代？**
   HotSpot的垃圾收集器是建立在分代假说的理论之上的，对不同年龄的对象分配在不同的内存区域以执行适用的回收算法

   - 新生代：创建的对象会优先存放在新生代的Eden区中，当Eden区没有足够空间时，发起一次Minor GC，GC期间若无法存入Survivor空间则通过分配担保机制提前转义到老年代中，否则将存入Survivor空间；

   - 老年代：当一个经过了多次GC还存活着，就证明该对象是比较有价值的，寿命超过了一定域值是晋升到老年代中，另外对于一些大的对象也会直接进入老年代；

5. **如何判断对象是否死亡？**

   - 可达性分析算法：通过GCRoots引用链判断对象是否可达，不可达则代表不再使用；
   - 引用计数算法：为对象添加一个引用计数器，每发生一次引用时数值就+1，当引用失效时-1，计数器为0时代表不被使用的。Java未采用的原因：很难解决对象之间互相循环引用的问题；

6. **简单介绍下强引用、软引用、弱引用、虚引用？它们之间有什么区别？**

   - 强引用：通过`new`创建的对象引用，当内存不足时，垃圾回收器不会回收该对象，而是抛出OutOfMemoryError异常；
   - 软引用（SoftRefrence）：在内存不足，抛出OutOfMemoryError之前，垃圾回收器会回收此类对象。软引用可用来实现内存敏感的高速缓存；
   - 弱引用（WeakRefrence）：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；
   - 虚引用（FanttomRefrence）：虚引用并不会决定对象的生命周期，主要用来跟踪对象被垃圾回收的活动；

7. **说一下JVM的自动内存管理？**
   JVM自动内存管理包含两部分：堆内存中对象的内存分配和内存回收：

   - 内存分配策略：
     - 对象优先在Eden区分配，当Eden区空间不足时，发起MinorGC；
     - 大对象和长期存活对象进入老年代，对象在Eden区经过MinorGC依然存活，将移动到Survivor中，年龄增加1岁，增加到一定年龄则移动到老年代中；
     - 动态年龄判定，Survivor区中相同年龄对象大小总和大于Survivor区空间的一半时，年龄大于前面的年龄时进入老年代；
     - 空间分配担保，在发生MinorGC之前，老年代最大可用连续空间是否大于新生代所有对象总空间，若满足，MinorGC可以确保安全的，否则查看HandlePromotionFailure的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次MinorGC；如果小于，或者HandlePromotionFailure的值不允许冒险，那么就要进行一次FullGC；
   - 内存回收：
     - Minor GC：新生代的垃圾收集，因为新生代对象存活时间很短，因此MinorGC会频繁执行，执行的速度一般也会比较快；
     - Major GC：老年代垃圾收集
     - Full GC：整个Java堆的和方法区的垃圾收集，老年代对象其存活时间长，因此FullGC很少执行，执行速度会比MinorGC慢很多；

8. **Eden区和Survivor区的设计理念？**

   由于新生代gc比较频繁、对象存活率低，用复制算法在回收时的效率会更高，也不会产生内存碎片。但复制算法的代价就是要将内存折半，为了不浪费过多的内存，就划分了两块相同大小的内存区域`survivor from`和`survivor to`。在每次gc后就会把存活对象给复制到另一个survivor上，然后清空Eden和刚使用过的survivor。

9. **什么是元空间（Metaspace）？**
   在JDK 1.8中引入了元空间概念，在这之前元空间作用的地方叫永久代，原来的永久代是在堆上的，而现在的元空间是在非堆上，使用非堆可以使用操作系统的内存，JVM的方法区不会再出现内存溢出，但无限制使用会造成操作系统的死亡。
   <img src="https://s2.loli.net/2022/09/13/iLXGfbY12ezgxZw.png" style="zoom:80%;" />

10. **什么是永久代？**
      永久代汇总包含了虚拟机中通过反射获取的所有数据，比如加载的类和方法，和用于描述类和方法的元数据都是存储在永久代中，当这些类不需要时会被回收，FullGC回对永久代进行回收。

11. **如何判断一个类是无用的类？**
    判断一个类是否不再使用要同时满足以下三个条件：

    - 该类的所有实例都被回收，也就是堆中不存在该类的任何实例；
    - 加载该类的ClassLoader已经被回收；
    - 该类对应的`java.lang.Class`对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法；

12. **如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？**
    不会立即释放对象占用的内存。   如果对象的引用被置为null，只是断开了当前线程栈帧中对该对象的引用关系，而   垃圾收集器是运行在后台的线程，只有当用户线程运行到安全点(safe point)或者安全区域才会扫描对象引用关系，扫描到对象没有被引用则会标记对象，这时候仍然不会立即释放该对象内存，因为有些对象是可恢复的（在   finalize方法中恢复引用   ）。只有确定了对象无法恢复引用的时候才会清除对象内存。

13. **哪些情况下的对象会被垃圾回收机制处理掉？**
    根据对象引用方式进行回收：

    - 强引用对象根据可达性分析为不再引用的对象；
    - 软引用对象在内存不足时被回收；
    - 弱引用在发生内存扫码时被回收；



### 2.3 线程（Basics Threads）

1. **线程与进程的区别？**
   - 线程是进程最小执行单元，一个进程至少包含一个线程，进程在执行过程中拥有独立的内存单元，而线程没有自己独立的内存单元，而是与其所在的进程之间共享资源。
   - 从Linux的角度来看，进程与线程都是一个`task_struct`结构体，除了是否共享资源外，没有其他本质的区别。
   
2. **如何正确结束一个Thread ？**
   - Java中线程的`stop()`、`suspend()`、`resume()`都已弃用，只能调用`interrupt()`通知系统停止线程，但并不能强制停止线程，线程能否停止，何时停止，取决于系统，如果线程处于阻塞状态时，使用`isInterrupted()`判断线程的中断标志来退出循环，当使用`interrupt()`后，中断标志会置为`true`；
   - 使用标记退出线程，通常用`volatile boolean`声明；

3. **Thread与Runnable的区别？**
   Thread和Runnable是继承关系，在用法上，如果有复杂的线程操作选继承，如果任务简单实现Runnable即可。

4. **`run()`与`start()`方法的区别？**

   - 调用`start()`方法将开启一个线程，这时线程处于就绪状态，一旦得到CPU时间片，就开始执行`run()`方法，`run()`方法执行结束，线程随即终止；
   - `run()`只是Thread的普通方法，在Thread开启后由JVM调用；

5. **`sleep()`与`wait()`方法的区别？**
   - `sleep()`属于Therad中的方法，作用是让当前线程进入停滞状态（阻塞线程），让出CPU时间片，但它的监控状态依然保持，当指定的时间结束后自动恢复运行状态，在唤醒之后不保证立即获得CPU时间片，而是会先进入就绪状态与其它线程竞争CPU时间片；
   - `wait()`属于Object中的方法，必须`synchronized`环境下使用，方法执行完后，需要额外的方法`notify()`、`notifyAll()`唤醒。`wait()`总是在一个循环中被调用，挂起当前线程来等待一个条件的成立；

6. **什么是线程池，如何使用？**

   - 线程池是一种基于池化思想管理线程的工具，主要有两部分组成：任务管理、和线程管理，以生产者消费者模式，通过一个阻塞队列缓存任务，工作线程从阻塞队列中获取任务执行；避免了在处理短时间任务时创建与销毁线程的代价，保证内核的充分利用，还能防止过分调度；
   - 如何使用：通过构造函数或者Executors创建线程池，创建Runnable或Callable任务让线程池处理；

7. **Java中有几种线程池？它们之间的原理是什么？**
   - 线程池：
     - FixedThreadPool 是一个可重用固定线程数的线程池；
     - SingleThreadExecutor 只有一个线程的线程池；
     - CacheThreadPool 根据需要而创建线程的线程池；
     - ScheduledThreadPoolExecutor 处理延迟任务或定期任务的线程池；
   - 原理：通过组合不同的线程数、任务队列实现不同的任务处理策略，以处理特定的业务场景；

8. **线程间同步的方式？**
   线程间同步的关键是避免共享资源的使用冲突，一般有以下几种同步方式：

   - 互斥量：synchronized和ReenreantLock
   - 信号量：volatile
   - 事件：wait/notify机制
   - 管道：PipedOutputStream/PipedInputStream，PipedReader/PipedWriter
   - join方法

   - ThreadLocal

9. **线程之间是如何通信的？**
   线程通信主要分为三种：共享内存、消息传递、管道流

   - 共享内存：线程之间共享程序的公共状态，之间通过读写内存中的公共状态来隐式通信，如：volatile；
   - 消息传递：线程之间没有公共的状态，线程之间必须通过明确的发送消息来显式通信，如：wait/notify、join；
   - 管道流：PipedOutputStream/PipedInputStream、PipedReader/PipedWriter；

10. **锁之间的区别？**

   - synchronized是Java关键字基于JVM层面实现加锁和释放锁，Lock是一个接口，在代码层面实现加锁和释放锁；
   - synchronized和Lock都是用来保护资源线程安全的，都可以保证可见性；
   - synchronized和ReentrantLoock都拥有可重入的特点；
   - ReadWriteLock定义了获取读锁和写锁的接口，读锁之间不互斥；

11. **乐观锁与悲观锁？**
    悲观锁认为自己在使用数据时一定有别的线程来修改数据，因此在获取数据时会先加锁，确保数据不会被别的线程修改，synchronized和Lock的实现类都是悲观锁；而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只在更新数据的时候采取判断执勤啊有没有别的线程更新过这个数据，如果数据没有被更新，当前线程将自己修改的数据成功写入，如果数据被其他线程更新了，则根据不同的实现方式执行不同的操作（例如：报错或自动重试）。

12. **线程死锁的4个条件？**
    - 互斥条件（mutual exclusion）：资源只能同时分配给一个进程，无法多个进程共享；
    - 请求与保持条件（hold and wait）：一个进程可以在等待资源而阻塞时，对持有的资源保持不放；
    - 不可剥夺条件（no preemption）：进程已获得的资源，在使用完之前，不可强行剥夺；
    - 循环等待条件（circular waiting）：一系列进程互相持有其他进程所需要的资源，形成一种头尾相接的循环等待资源关系；

13. **什么是深拷贝和浅拷贝？**
    Java中在对象的赋值操作中，对于基本类型赋值的是属性值，对于引用类型赋值的是对象的引用地址，而浅拷贝和深拷贝是在赋值的基础上进行区分：

    - 浅拷贝对于基本值类型拷贝的是属性值，对于引用类型则拷贝的是引用地址；
    - 深拷贝是一种完全拷贝，无论是基本类型或引用类型都会在内存中创建一个新的对象，则源对象与新对象互相独立；java clone String

14. **一个实现Cloneable的类中，`clone()`后的String类型数据，是深拷贝还是浅拷？**
    String本身没有实现Cloneable接口，故无法进行克隆，只能传递引用，在`clone()`之后，指向的值为常量，当改变克隆出来的String对象的内容时，并不会影响被克隆的值和其内容的指向，这样String在拷贝时就表现出了深拷贝的特点。

15. **对并发编程的了解？**
    让计算机可以在一个时间段内执行多个任务，充分的利用处理器性能，同时通过各种手段解决并发性可能带来的多个执行路径和结果的不确定性。

16. **多线程断点续传的实现原理？**
    HTTP分块传输：Rang、Content-Range、Last-Modified、ETag、If-Range

17. **有三个线程 T1、T2、T3 怎么确保它们按顺序执行？**

    - `Thread.join()`
    - 线程池的队列任务

18. **什么是守护线程？你是如何退出一个线程的？**

    - Java的线程分为两种：用户线程和守护线程，守护线程（Deamon Thread）是一个服务线程，用于服务其他（用户）线程，在JVM中，所有用户线程执行完毕后，无论有无守护线程，JVM都会自动退出。守护线程最典型的就是垃圾回收线程。
    - `interrupt()`

19. **多线程引发的性能问题怎么解决？**

    - 死锁：破坏产生死锁额四个必要条件;
    - 锁竞争：减少锁竞争的主要方法是：减少锁的持有时间、降低锁的请求频次、或者使用带有协调机制的独占锁替代；
    - 内存同步：减少和避免同步带来的开销，如使用线程局部变量ThreadLocal、使用基于CAS的替代方案

    或；

    - 上下文切换：减少线程的上下文切换，如合理设置线程池大小、减少GC中的*Stop The World*场景；

20. **线程的生命周期？**

    初始状态、可运行状态、阻塞状态、运行状态、终止状态

21. **什么导致线程阻塞？**
    `sleep()`、`wait()`、`yield()`、`join()`

22. **Copy-On-Write是什么？**
    一种写时复制的优化策略，多个调用者使用相同资源时，读操作可以共享同一份资源，在视图修改资源时才复制一份副本给调用者，其他保持不变。

23. **JMM怎么解决可见性，原子性，有序性问题的？**

    - 原子性：字节码指令`monitorenter`和`monitorexit`可以保证`synchronized`代码块中的操作是原子的；
    - 可见性：`volatile`修饰的变量在修改后立即同步到主存，每次使用前都从主存刷新，以保证多线程操作时变量的可见性；
    - 有序性：`synchronized`和`volatile`都可以保证多线程之间操作的有序性，但实现方式有所区别，`volatile`会禁止指令重排，`synchronized`保证同一时刻只允许一条线程操作；

24. **Java中Runnable和Callable有什么不同？**
    Runnable的`run()`方法无返回值，Callable的`call()`方法有返回值，配合Fature获取异步执行结果，Runnable的`run()`方法只能抛出运行时异常，且无法捕获，Callable的`call()`方法允许抛出异常，可以获取异常信息。

25. **什么是线程安全？如何确保线程安全？**

    - 线程间同时使用共享资源或通信时，不需要额外的保障措施就可以获得正确的结果即是线程安全；

    - 线程安全的实现方法：

      - 互斥同步：指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条线程使用，例如`synchronized`、`ReentrantLock`等；

      - 非阻塞同步：CAS操作，比如`AtomicInteger`、`AtomicLong`；
      - 无同步方案：保证代码的可重入性，必须共享数据是可以通过ThreadLocal把数据的可见范围控制在同一线程内；

26. **一个线程运行时发生异常会怎样？**
    如果异常没有被捕获，该线程将会停止执行。当一个未捕获的异常造成线程终端时，JVM会使用线程的 UncaughtExceptionHandler的`uncaughtException()`方法处理异常。

27. **`notify`和`notifyAll`有什么区别？**
    `notify`会从等待池中随机唤醒一个线程到锁池，`notifyAll`会将等待池中所有线程唤醒到锁池，锁池中线程将竞争所的使用权，优先级高的线程竞争到锁的概率大一些。

28. **什么是ThreadLocal变量？**
    ThreadLocal通过每个线程提供一个独立的ThreadLocalMap副本来存储值，值只能被当前线程读取和修改，从而实现变量访问在不同线程中隔离。

29. **为什么`wait()`和`notify()`方法要在同步快中调用？**
    `wait()`和`notify()`这两个方法存在竞态条件，所以需要一种同步机制保证他们之间是互斥的，否则`wait()`被调用时有可能条件已经不满足，在进行`wait()`会导致永远不会被`notify()`到。

30. **Java中的同步集合与并发集合有什么区别？**

    同步集合通过`synchronized`限制同一时刻只有一个线程使用容器，将多线程变成串行等待执行，以保证线程安全，但复合操作不能保证线程安全；并发集合是允许多线程同时使用容器，通过：锁、CAS操作、COW策略、分段锁等来保证线程安全并提高并发的执行效率。

31. **Java中堆和栈有什么不同？**

    - 栈是线程私有的，堆是所有线程共享的；
    - 栈用来存储局部变量、对象的引用变量和方法调用，堆用来存储实例化的对象；
    - 内存空间不足时，栈抛出StackOverFlowError异常，堆抛出OutOfMemoryErorr异常；

32. **怎么检测一个线程是否拥有锁？**

    - 使用synchronized时，用`Thread.holdsLock(lockObject)`判断；
    - 使用ReentrantReadLock、ReentrantWriteLock时，用`isHeldByCurrentThread()`判断；



### 2.4 并发（Concurrent）





### Design Pattern

1. **六大设计原则？**
   单一职责原则、开闭原则、里氏替换原则、接口分离、依赖倒置原则、最小知识原则
2. 对双亲委派模型的了解？



### Serialization

1. **什么是序列化？怎么实现？有哪些方式？**
   - 定义：
     - 是一种用来处理对象流的机制，将对象的内容进行流化（将对象转换成二进制），然后将流化后的对象进行读或传输于网络之间；
     - 序列化主要是为了解决在对对象流进行读写操作时所引发的问题；
   - 实现：将需要被序列化的类实现`Serializable`接口，系统会标注该对象是可被序列化的，然后使用输出流（例如：`FileOutputSteam`）构造一个流对象`ObjectOutputStream`，使用`.writeObject(Object obj)`可将`object`对象输出；相反的话则用输入流；
   - 实现方式（性能由低至高）：Java Serialization < Json < FastJson < Hession < Dubbo < FST < Kryo；



### Java 进阶

1. **对反射的了解？**
   反射是指程序在运行期可以访问、检查和修改它自身的状态或行为的一种能力。例如：可以在运行期间构造任意一个类的对象，了解任意一个对象所属的类，还可以调用类的成员方法、成员变量。
   
2. **什么时候使用反射？**
   - 使用三方库时，需要扩展功能或修复功能时；
   - 使用动态代理；
   
3. **反射可以反射`final`修饰的字段吗？**
   可以，通过`Field.setAccessible(true)`将`private`修饰为`accessible`，再将`final`去除，然后设置新值即可。但如果涉及Java内联优化，则会失效。
   
4. **说说你对注解的了解，是怎么解析的？编译时注解和运行时注解的区别？**
   - 注解：注解就是定义在类、方法或字段前的元数据，这些元数据可以通过API在编译期间、类加载、运行期间读取，并执行相应的处理；
   - 解析：注解只有被解析之后才生效，常见的解析方法有两种：
     - 编译器直接扫描：编译期扫描Java代码对应的注解并处理；
     - 运行期通过注解处理器和反射处理；
   - 编译时注解与运行时注解的区别：编译注解是在编译期间通过`apt tools`获取注解内容进行处理，运行时注解是在运行期间通过反射获取注解内容进行处理；
   
5. **编译期注解处理的是字节码还是java文件？**
   注解处理器是以java源代码或已编译的字节码作为输入的。
   
6. **对依赖注入的了解？**
   依赖注入是一种设计模式，也是实现控制反转的其中一种技术，能够让一个对象接收它所依赖的其他对象，并且把依赖对象的创建和销毁的控制权交给外部来处理。
   
7. **对Java异常体系的了解？**
   Throwable是Error和Exception的超类，提供了线程的执行堆栈的快照用于跟踪，Error指Java运行时系统的内部错误和资源耗尽错误，Exception指程序本身可以捕获和处理的异常，Exception又分为运行时异常和非运行时异常，跟距Java语言规范的定义，Error和RuntimeException属于不受检异常（unchecked）即在编译过程中不处理此类异常也可正常通过编译，反过来，非运行时异常也称编译时异常，是属于受检异常（checked）的类型，即在编译过程中没有被`catch`或`throw`处理则无法通过编译。

8. **Exception和Error的区别？**
   Exception是程序本身可以处理的异常，可以通过`catch`捕获，Error属于程序无法处理的错误，这些异常发生时，Java虚拟机一般会选择线程终止。

9. **Java 7和Java 8的区别？**

   - lambda表达式
   - 接口可定义默认方法
   - HashMap引入了红黑树
   - 可重复标记的注解Repeatable

10. **对解析与分派的了解？**

    - 解析与分派是方法调用的不同形式，指的是它们在不同层次上去筛选、确定目标方法的过程；
    - 解析指的是方法调用的引用在类加载的解析阶段从class文件中的符号引用转换成运行时内存布局中的直接引用的过程，这是个静态的过程，即编译器就可以确定，不必延迟到运行期再去完成；
    - 分派则分为静态分派和动态分派，同时根据方法的接收者与方法参数的宗量分为单分派与多分派；
      - 静态分派是指所有依赖静态类型来决定方法执行版本的分派，最典型的应用时方法重载；
      - 动态分派指在运行期根据实际类型确定方法执行版本的分派，方法重写就是动态分派的过程；

11. **谈谈对Java状态机理解？**
    状态机表示有限的状态以及状态之间的转移和动作等行为，一般状态机包含几个元素：

    - State：当前状态
    - Event：触发事件
    - Transition：状态转换
    - Action：要执行的动作

    在Java中实现状态机计算模型的方式有：switch/case、状态模式、枚举等；

12. **Java和字节码有什么区别？**
    java是开发者根据java语言规范编写的源代码，则是面向开发者的，而class字节码是通过编译器转换而成，是虚拟机执行的数据，是面向虚拟机的。

13. **静态代理和动态代理的区别？有什么场景使用？**

    - 区别：
      1. 静态代理需要代理对象与目标对象实现同一接口，且一个代理对象只能为一个目标对象服务，动态代理不需要实现接口，可以代理多个目标对象；
      2. 静态代理在编译期生成，可直接使用、效率高，动态代理在运行时动态生成，通过反射代理，比较消耗系统性能，使用更灵活；
    - 使用场景：
      1. 静态代理：延迟初始化、访问控制
      2. 动态代理：AOP、RPC远程过程调用

