---
title: Design Pattern
date: 2018-01-23 21:30:50
updated: 2018-01-23 21:30:50
tags: [设计模式]
---



<!--more-->



## 设计模式

**设计模式**是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。

设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。

### 设计模式分类

| 模式 & 描述                                                  | 包括                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **创建型模式**<br>提供了一种在创建对象的同时隐藏创建逻辑的方式。 | 工厂模式（Factory Pattern）<br>抽象工厂模式（Abstract Factory Pattern）<br>单例模式（Singleton Pattern）<br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern） |
| **结构型模式**<br>关注类和对象的组合。                       | 适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern） |
| **行为型模式**<br>特别关注对象之间的通信。                   | 责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern） |



## 创建型模式

### 单例模式

#### 懒汉模式

#### 饿汉模式

#### 双检锁

#### 静态内部类

#### 枚举



### 工厂方法模式

工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![](../images/design-patterns/factory-method.png)

#### 😒 问题

假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 `卡车`的类中。

一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。

你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。

#### 😊 解决方案

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

![子类可以修改工厂方法返回的对象类型](../images/design-patterns/factory-method-programme.png)

乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。

但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![所有产品都必须使用同一接口](../images/design-patterns/factory-method-programme2.png)

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `运输` 。 客户端知道所有运输对象都提供 `交付`方法， 但是并不关心其具体实现方式。

#### 工厂方法模式结构

![](../images/design-patterns/factory-method-pattern.png)

1. **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

2. **具体产品** （Concrete Products） 是产品接口的不同实现。

3. **创建者** （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。

   你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

   注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。

4. **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

   注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

##### 工厂方法模式适合应用场景



## 结构型模式

结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

### 外观模式

外观模式是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。

![](../images/design-patterns/facade-pattern.png)

#### 😒 问题

假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。

最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。

#### 😊 解决方案

外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。

#### 外观模式结构

![](../images/design-patterns/facade-pattern-frame.png)

1. **外观（Facade）**提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。

2. 创建**附加外观（Additional Facade）**类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。

3. **复杂子系统（Complex Subsystem）**由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。

   子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。

4. **客户端（Client）**使用外观代替对子系统对象的直接调用。

#### 享元模式

享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方法，通过共享多个对象所共有的相同状态，让你在有限的内容中载入更多对象。

![](../images/design-patterns/flyweight-pattern.png)



### 代理模式

代理模式是一种结构型设计模式，让你能够提供对象的代替品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

#### 😒 问题

为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。

![代理模式解决的问题](/Users/mcgrady/Pictures/gallery/design-patterns/proxy-pattern-problem.png)

数据库查询有可能会非常缓慢。

你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。

在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。

#### 代理模式适合的场景





## 行为型模式

行为模式负责对象间的高效沟通和职责委派。

### 责任链模式

责任链模式是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

![](../images/design-patterns/CoR-pattern.png)

#### 责任链模式结构

![](../images/design-patterns/CoR-pattern-frame.png)

1. **处理者（Handler）**声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。

2. **基础处理者（Base Handler）**是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。

   通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。

3. **具体处理者（Concrete Handlers）**包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。

   处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。

4. **客户端（Client）**可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。



### 策略模式

策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

策略模式建议找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中。

名为**上下文**的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。

上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。

因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。

![](../images/design-patterns/strategy-pattern.png)

#### 策略模式结构

![](../images/design-patterns/strategy-pattern-frame.png)

1. **上下文** （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。
2. **策略** （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。
3. **具体策略** （Concrete Strategies） 实现了上下文所用算法的各种不同变体。
4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。
5. **客户端** （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。











## SOLID设计原则

SOLID指面向对象编程的五个基本设计原则，有助于构建**清晰可读**的、**易于维护和扩展**的系统。

### 单一职责原则（Single responsibility principle）

保持一个类或模块专注于单一的功能。可以使得类或模块更加健壮，同时降低功能之间的依赖关系。

建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起的变化。



### 开闭原则（The Open/Closed Principle, OCP）

开闭原则规定软件中的对象（类、模块、函数等）应该对于扩展是开放的，但对于修改是封闭的。意味着源代码在对外扩展时并不需要改变自身的行为。



### 里氏替换原则（Liskov Substitution principle）

里式替换原则是在一场名为“数据的抽象与层次”的演讲中提出，是对子类型的特别定义，描述为**子类对象可以在程序中代替其基类对象**。

建议使用继承时应遵循里式替换原则。



### 接口分离原则（Interface-Segregation Principle, ISP）

接口分离原则指明Client（接口使用者）不应被迫使用对其而言无用的方法或功能。通过拆分非常庞大臃肿的接口称为更小的或更具体的接口，这样Client才会将只需要他们感兴趣的方法。从而使得接口更易于重构、更改和重新部署。



### 依赖倒置原则（Dependency inversion principle，DIP）

依赖倒置原则是一种特定的解耦形式[^解耦形式]，规定了：

1. 高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；
2. 抽象接口不应该依赖于具体实现，而具体实现则应该依赖于抽象接口；

[^解耦形式]: 在传统的自顶向下的依赖关系中，低层次模块是对高层模块接口的具体实现，即高层模块创建在高层次上，而具体的策略则应用在低层次的模块的上。

依赖倒置原则的目的是把高层次组件从低层次组件的依赖中解耦出来，这样使得重用不同层级的组件实现变得可能。

```java
public class Client {

	public static void main(String[] args) {
        
        // 通过构造传递依赖对象
        ICar brz = new Brz();
        IDriver jacket = new Driver(brz);
        jacket.drive();
        
        // 通过接口声明依赖对象
        IDriver jacket = new Driver();
        ICar brz = new Brz();
        jacket.drive(brz);
        
        // 通过Setter方法传递依赖对象
        IDriver jacket = new Driver();
        jacket.setCar(new Brz());
        jacket.drive();
	}
}

public interface ICar {
	public void run();
    //or
    public void run(ICar car);
}

public class Brz implements ICar {
	@Override
	public void run() {
		System.out.println("Brz start running");
	} 
}

public interface IDriver {
	public void drive();
}

public class Driver implements IDriver {

    private ICar car;
    
    public Driver(ICar car) {
        this.car = car;
    }
   
	@Override
	public void drive() {
		car.run();
	}
    //or
    @Override
    public void drive(ICar car) {
        car.run();
    }
    
    public void setCar(Icar car) {
        this.car = car;
    }
}
```



### 迪米特法则（Law of Demeter, LoD）

迪米特法则又称最少知识原则（Principle of Least Knowledge），是一种松耦合的具体案例，规定了每个软件实体单元尽可能少的与其他单元发生相互作用，而且局限于与本单位密切相关的单位。

迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得模块功能独立，相互之间不存在（或很少）依赖关系。









