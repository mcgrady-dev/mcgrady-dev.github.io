---
title: Design Pattern
date: 2018-01-23 21:30:50
updated: 2018-01-23 21:30:50
tags: [android]
categories: android
---

# Design Pattern



## SOLID 设计原则

### 单一职责原则（The Single Responsibility Principle ）

#### 类的单一原则
#### 接口的单一原则

接口的单一的职责是**定义单一职责或相关职责的一组方法。**

#### 方法的单一原则

方法的单一职责原则是**一个方法实现一个功能，解决一个方法。**

#### 总结

**单一职责原则的优点：**

- 降低复杂性
- 提高可读性
- 提高可维护性

**单一原则的定义：**

单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或
类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。
对于单一职责原则，**建议接口一定要做到单一职责，类的设计尽量做到只有一个原因引起的变化**。



### 开放封闭原则（The Open Closed Principle ）

#### 定义

**一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。**

#### 总结

**这个原则有两个特性，一个是说“对于扩展是开放的”，另一个是说“对于更改是封闭的”。面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是“开放-封闭原则”的精神所在。**



### 里氏替换原则（The Liskov Substitution Principle ）

#### 定义1
如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。
#### 定义2
**所有引用基类的地方必须能透明地使用其子类的对象**。

通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。

#### 总结

继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。
**使用继承时应遵循里式替换原则。**



### 依赖倒置原则（The Dependency Inversion Principle ）

#### 定义
高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

#### 总结

**依赖倒置原则就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。**

```java
public class Client {

	public static void main(String[] args) {
        
        // 通过构造传递依赖对象
        ICar brz = new Brz();
        IDriver jacket = new Driver(brz);
        jacket.drive();
        
        // 通过接口声明依赖对象
        IDriver jacket = new Driver();
        ICar brz = new Brz();
        jacket.drive(brz);
        
        // 通过Setter方法传递依赖对象
        IDriver jacket = new Driver();
        jacket.setCar(new Brz());
        jacket.drive();
	}
}

public interface ICar {
	public void run();
    //or
    public void run(ICar car);
}

public class Brz implements ICar {
	@Override
	public void run() {
		System.out.println("Brz start running");
	} 
}

public interface IDriver {
	public void drive();
}

public class Driver implements IDriver {

    private ICar car;
    
    public Driver(ICar car) {
        this.car = car;
    }
   
	@Override
	public void drive() {
		car.run();
	}
    //or
    @Override
    public void drive(ICar car) {
        car.run();
    }
    
    public void setCar(Icar car) {
        this.car = car;
    }
}
```



### 接口分离原则（The Interface Segregation Principle ）

#### 定义

建立功能单一细化的接口，接口中的方法尽量少，避免接口庞大臃肿。通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

## 设计模式

### 设计模式是什么？

**设计模式**是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。

设计模式与方法或库的使用方式不同， 你很难直接在自己的程序中套用某个设计模式。 模式并不是一段特定的代码， 而是解决特定问题的一般性概念。 你可以根据模式来实现符合自己程序实际所需的解决方案。



### 单例模式

#### 懒汉模式

#### 饿汉模式

#### 双检锁

#### 静态内部类

#### 枚举





### 创建型模式

创建型模式提供创建对象的机制，增加已有代码的灵活性和可复用性。

#### 工厂方法模式

工厂方法模式是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

![](../images/design-patterns/factory-method.png)

##### 😒 问题

假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 `卡车`的类中。

一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。

你将不得不编写繁复的代码， 根据不同的运输对象类， 在应用中进行不同的处理。

##### 😊 解决方案

工厂方法模式建议使用特殊的*工厂*方法代替对于对象构造函数的直接调用 （即使用 `new`运算符）。 不用担心， 对象仍将通过 `new`运算符创建， 只是该运算符改在工厂方法中调用罢了。 工厂方法返回的对象通常被称作 “产品”。

![子类可以修改工厂方法返回的对象类型](../images/design-patterns/factory-method-programme.png)

乍看之下， 这种更改可能毫无意义： 我们只是改变了程序中调用构造函数的位置而已。 但是， 仔细想一下， 现在你可以在子类中重写工厂方法， 从而改变其创建产品的类型。

但有一点需要注意:仅当这些产品具有共同的基类或者接口时， 子类才能返回不同类型的产品， 同时基类中的工厂方法还应将其返回类型声明为这一共有接口。

![所有产品都必须使用同一接口](../images/design-patterns/factory-method-programme2.png)

调用工厂方法的代码 （通常被称为*客户端*代码） 无需了解不同子类返回实际对象之间的差别。 客户端将所有产品视为抽象的 `运输` 。 客户端知道所有运输对象都提供 `交付`方法， 但是并不关心其具体实现方式。

##### 工厂方法模式结构

![](../images/design-patterns/factory-method-pattern.png)

1. **产品** （Product） 将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。

2. **具体产品** （Concrete Products） 是产品接口的不同实现。

3. **创建者** （Creator） 类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。

   你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者， 你也可以在基础工厂方法中返回默认产品类型。

   注意， 尽管它的名字是创建者， 但他最主要的职责并**不是**创建产品。 一般来说， 创建者类包含一些与产品相关的核心业务逻辑。 工厂方法将这些逻辑处理从具体产品类中分离出来。 打个比方， 大型软件开发公司拥有程序员培训部门。 但是， 这些公司的主要工作还是编写代码， 而非生产程序员。

4. **具体创建者** （Concrete Creators） 将会重写基础工厂方法， 使其返回不同类型的产品。

   注意， 并不一定每次调用工厂方法都会**创建**新的实例。 工厂方法也可以返回缓存、 对象池或其他来源的已有对象。

##### 工厂方法模式适合应用场景



### 结构型模式

结构型模式介绍如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效。

#### 外观模式

外观模式是一种结构型设计模式，能为程序库、框架或其他复杂类提供一个简单的接口。

![](../images/design-patterns/facade-pattern.png)

##### 😒 问题

假设你必须在代码中使用某个复杂的库或框架中的众多对象。 正常情况下， 你需要负责所有对象的初始化工作、 管理其依赖关系并按正确的顺序执行方法等。

最终， 程序中类的业务逻辑将与第三方类的实现细节紧密耦合， 使得理解和维护代码的工作很难进行。

##### 😊 解决方案

外观类为包含许多活动部件的复杂子系统提供一个简单的接口。 与直接调用子系统相比， 外观提供的功能可能比较有限， 但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。

##### 外观模式结构

![](../images/design-patterns/facade-pattern-frame.png)

1. **外观（Facade）**提供了一种访问特定子系统功能的便捷方式， 其了解如何重定向客户端请求， 知晓如何操作一切活动部件。

2. 创建**附加外观（Additional Facade）**类可以避免多种不相关的功能污染单一外观， 使其变成又一个复杂结构。 客户端和其他外观都可使用附加外观。

3. **复杂子系统（Complex Subsystem）**由数十个不同对象构成。 如果要用这些对象完成有意义的工作， 你必须深入了解子系统的实现细节， 比如按照正确顺序初始化对象和为其提供正确格式的数据。

   子系统类不会意识到外观的存在， 它们在系统内运作并且相互之间可直接进行交互。

4. **客户端（Client）**使用外观代替对子系统对象的直接调用。

#### 享元模式

享元模式是一种结构型设计模式，它摒弃了在每个对象中保存所有数据的方法，通过共享多个对象所共有的相同状态，让你在有限的内容中载入更多对象。

![](../images/design-patterns/flyweight-pattern.png)



#### 代理模式

代理模式是一种结构型设计模式，让你能够提供对象的代替品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。

##### 😒 问题

为什么要控制对于某个对象的访问呢？ 举个例子： 有这样一个消耗大量系统资源的巨型对象， 你只是偶尔需要使用它， 并非总是需要。

![代理模式解决的问题](../images/design-patterns/proxy-pattern-problem.png)

数据库查询有可能会非常缓慢。

你可以实现延迟初始化： 在实际有需要时再创建该对象。 对象的所有客户端都要执行延迟初始代码。 不幸的是， 这很可能会带来很多重复代码。

在理想情况下， 我们希望将代码直接放入对象的类中， 但这并非总是能实现： 比如类可能是第三方封闭库的一部分。

### 行为模式

行为模式负责对象间的高效沟通和职责委派。

#### 责任链模式

责任链模式是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链上的下个处理者。

![](../images/design-patterns/CoR-pattern.png)

##### 责任链模式结构

![](../images/design-patterns/CoR-pattern-frame.png)

1. **处理者（Handler）**声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法。

2. **基础处理者（Base Handler）**是一个可选的类， 你可以将所有处理者共用的样本代码放置在其中。

   通常情况下， 该类中定义了一个保存对于下个处理者引用的成员变量。 客户端可通过将处理者传递给上个处理者的构造函数或设定方法来创建链。 该类还可以实现默认的处理行为： 确定下个处理者存在后再将请求传递给它。

3. **具体处理者（Concrete Handlers）**包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。

   处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。

4. **客户端（Client）**可根据程序逻辑一次性或者动态地生成链。 值得注意的是， 请求可发送给链上的任意一个处理者， 而非必须是第一个处理者。



#### 策略模式

策略模式是一种行为设计模式，它能让你定义一系列算法，并将每种算法分别放入独立的类中，以使算法的对象能够相互替换。

策略模式建议找出负责用许多不同方式完成特定任务的类，然后将其中的算法抽取到一组被称为策略的独立类中。

名为**上下文**的原始类必须包含一个成员变量来存储对于每种策略的引用。 上下文并不执行任务， 而是将工作委派给已连接的策略对象。

上下文不负责选择符合任务需要的算法——客户端会将所需策略传递给上下文。 实际上， 上下文并不十分了解策略， 它会通过同样的通用接口与所有策略进行交互， 而该接口只需暴露一个方法来触发所选策略中封装的算法即可。

因此， 上下文可独立于具体策略。 这样你就可在不修改上下文代码或其他策略的情况下添加新算法或修改已有算法了。

![](../images/design-patterns/strategy-pattern.png)



##### 策略模式结构

![](../images/design-patterns/strategy-pattern-frame.png)

1. **上下文** （Context） 维护指向具体策略的引用， 且仅通过策略接口与该对象进行交流。
2. **策略** （Strategy） 接口是所有具体策略的通用接口， 它声明了一个上下文用于执行策略的方法。
3. **具体策略** （Concrete Strategies） 实现了上下文所用算法的各种不同变体。
4. 当上下文需要运行算法时， 它会在其已连接的策略对象上调用执行方法。 上下文不清楚其所涉及的策略类型与算法的执行方式。
5. **客户端** （Client） 会创建一个特定策略对象并将其传递给上下文。 上下文则会提供一个设置器以便客户端在运行时替换相关联的策略。























