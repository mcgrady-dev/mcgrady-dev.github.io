## 第1章 异步程序设计介绍

Kotlin 协程主要应用于构建各类异步程序模型

### 1.1 异步的概念

按照指令执行顺序的特征，程序执行分为**同步执行**和**异步执行**。

### 1.2 异步程序设计的关键问题

#### 1.2.1 结果传递

Kotlin 协程的挂起函数（suspend function）本质上就采取了异步返回值的设计思路

#### 1.2.2 异常处理

异步逻辑同步化是 Kotlin 协程要解决的问题

#### 1.2.3  取消响应

#### 1.2.4 复杂分支



### 1.3 常见异步程序设计思路

#### 1.3.3 Promise

Promise是一个异步任务，它存在**挂起**、**完成**、拒绝三个状态，与它相似的有：

- Java#CompletableFuture
- JavaScript#Promise
- RxJava#Single

#### 1.3.4 响应式编程

Reactive Programming（响应式编程）主要关注的是数据流的变化和流转，因此它更注重描述数据输入和输出之间的关系。输入和输出之间用函数变换来连接，函数之间也只对输入输出负责。

#### 1.3.5 Kotlin 协程

suspend 关键字修饰的函数称为挂起函数，表示该函数支持同步化的异步调用。同时也表示挂起点，该函数包含了异步调用和回调两层含义。



## 第2章 协程的基本概念

### 2.1 协程究竟是什么

协程的概念最核心的点就是函数或者一段程序能够被挂起，稍后再在挂起的位置恢复。挂起和恢复是开发者的程序逻辑自己控制的，协程是通过主动让出运行权来实现写作的，因此它本质上是在讨论程序控制流程的机制。

### 2.2 协程的分类

#### 2.2.1 按调用栈分类

通常我们提及调用栈，指的是函数调用栈，是一种用来保存函数调用时的状态信息的数据结构。

**由于协程需要支持挂起、恢复，因此对于挂起点的状态保存就显得极其关键。类似的，线程会因为CPU调度权的切换而被中断，它的中断状态会保存在调用栈当中，因而协程的实现也可以按照是否开辟相应的调用栈来分类。**

- Stackful Coroutine（有栈协程）：每一个协程都会有自己的调用栈，有点类似于线程的调用栈，这种情况下的协程实现其实很大程度上接近线程，主要不同体现在调度上。
- Stackless Coroutine（无栈协程）：协程没有自己的调用栈，挂起点的状态通过**状态机**或者**闭包等语法**来实现。

Kotlin的协程通常被认为是一种无栈协程的实现，它的控制流转依靠对协程体本身编译生成的状态机的状态流转来实现，变量保存也是通过闭包语法来实现的。不过，Kotlin的协程可以在挂起函数范围内的任意调用层次挂起，换句话说，在一个协程作用域中，可以在其中任意嵌套suspend函数，而这又恰恰是有栈协程最重要的特性之一。

> 关于协程实现究竟属于有栈协程还是无栈协程的问题，实际上争论较多，争议点主要是调用栈本身的定义及协程实现形式上的差异。从狭义上讲，调用栈就是我们熟知的普通函数的调用栈；从广义上讲，只要是能够保存调用状态的栈都可以称为调用栈，因而有栈协程的定义也可以更加宽泛。本书中若无特别说明，调用栈均特指普通函数调用栈，并按照这个标准对协程进行分类。

#### 2.2.2 按调度方式分类

调度过程中，根据协程调度权的转移目标的不同又可将协程分为**对称协程**和**非对称协程**。

- Sysmmetric Coroutine（对称协程）：任何一个协程都是互相独立且平等的，调度权可以在任意协程之间转移。
- Asymmetric Coroutine（非对称协程）：协程出让调度权的目标只能是它的调用者，即协程之间存在调用和被调用关系。

从实现的角度来讲，非对称协程的实现更加自然，不过只要对非对称协程稍作修改，即可实现对称协程的能力。在非对称协程的基础上添加一个重力的第三方作为协程调度权的分发中心，所有的协程在挂起时豆浆控制权转移给分发中心，分发中心根据参数来决定将调度权转移给目标线程，例如：Kotlin 中基于 Channel 的通信。



### 2.3 协程的实现举例

#### 2.3.2 Lua标准库的协程实现

协程包括一下部分：

- **协程的执行体**，主要指启动协程时对应的函数
- **协程的控制实例**，通过协程创建时返回的实例控制协程的调用流转，我们将该对象的类型称为协程的描述类。
- **协程的状态**，在调用流程转移前后，协程的状态会发生相应的变化。



## 第3章 Kotlin协程的基础设施

### 3.1 协程的构建

### 3.2 函数的挂起

#### 3.2.1 挂起函数

所谓协程的挂起其实就是程序执行流程发生异步调用时，当前调用流程的执行状态进入等待状态。

> 注意，挂起函数不一定真的会挂起，只是提供了挂起的条件。

#### 3.2.2 挂起点

**在协程内部挂起函数的调用处被称为挂起点**。挂起点如果出现异步调用，那么当前协程就被挂起，知道对应的 Continuation 的`resume`函数被调用才会恢复执行。而异步调用是否发生，取决于 **`resume` 函数与对应的挂起函数的调用是否在相同的调用栈上**，切换函数调用栈的方法可以是切换到其它线程上执行，也可以是不切换线程但在当前函数返回之后的某一时刻再执行。

#### 3.2.3 CPS变换

CPS变换（Continuation-Passing-Style Transformation），是通过传递 Continuation 来控制异步调用流程。

Kotlin协程挂起时就将挂起点的信息保存到了 Continuation 对象中。Continuation 携带了协程继续执行所需的上下文，恢复执行的时候只要执行它的恢复调用并且把需要的参数或异常传入即可。

挂起函数挂起，执行异步逻辑。此时函数的实际返回值是一个**挂起标志**，通过这个标志外部协程就可以知道该函数需要挂起等到异步逻辑执行。在Kotlin中这个标志是个常量，定义在`Intrinsics.kt`当中：

```kotlin
public val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED

internal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }
```

挂起函数一定要运行在协程体内或其它挂起函数中的原因是，**任何一个协程体或挂起函数中都有一个隐含的 Continuation 实例**，编译器能够对这个实例进行正确传递，并将这个细节隐藏在协程的背后，让我们的异步代码看起来像同步代码一样。



### 3.3 协程上下文

Continuation 除了可以通过恢复调用来控制执行流程的异步返回意外，还有一个重要的属性 context，即协程的上下文。

#### 3.3.1 协程上下文的集合特征

> 上下文在各自的场景主要承载了资源获取、配置管理等工作，是执行环境相关的通用数据资源的统一提供者。

```kotlin
interface CoroutineContext {
  public operator fun <E : Element> get(key: Key<E>): E?
  
  public interface Element : CoroutineContext {
        /**
         * A key of this coroutine context element.
         */
        public val key: Key<*>

        public override operator fun <E : Element> get(key: Key<E>): E? =
            @Suppress("UNCHECKED_CAST")
            if (this.key == key) this as E else null

        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =
            operation(initial, this)

        public override fun minusKey(key: Key<*>): CoroutineContext =
            if (this.key == key) EmptyCoroutineContext else this
    }
}
```

**Element**

- Element 本身也实现了 CoroutineContext 接口，这看上去好像很奇怪，其实这主要是为了 API 设计方便，Element 中是不会存放除了自己意外额其他数据的。
- Element 中的 key 属性很关键，是协程上下文集合中元素的索引。



### 3.4 协程的拦截器

协程启动调用一次「恢复调用」，通过「恢复调用」来开始执行协程体从开始到下一次挂起之间的逻辑。挂起点处如果异步挂起，则在恢复时调用一次。由此克制，「恢复调用」的次数为`1+n`次，其中`n`是协程体内真正挂起执行异步逻辑的挂起点的个数。

### 3.5 Kotlin协程所属的类别

#### 3.5.1 调用栈的广义和狭义

如果我们狭义地认为调用栈就只是类似于线程为函数提供的调用栈的话，那么既然无法在任意层次普通函数调用内实现挂起，我们因此就可以将Kotlin协程视为无栈协程的实现；但从挂起函数可以实现任意层次嵌套调用内挂起的效果来讲，确实也可以将Kotlin协程视为一种有栈协程的实现。

#### 3.5.2 调度关系的对立和统一

非对称的协程API设计更符合我们的思维习惯，调用有来有回，形成闭环；而对称协程则更能体现出协程的独立性和协作性。独立性指各协程之间不会因调用关系而存在从属关系，协作性是指对称的协程尤其需要明晰自身职责，就像生产线上的不同环节一样有序配合。

尽管很明显Kotlin的挂起函数是非对称调用的例子，Kotlin一样可以有自己的对称协程的实现（Channel）。



### 3.6 本章小结

协程是一个支持挂起和恢复的程序，而Kotlin协程是基于 Continuation 来实现挂起和恢复的。



## 第4章 Kotlin协程的拓展实践

Kotlin协程虽然被归类为”无栈非对称“，但这并不是绝对的，完全可以基于Kotlin的基础设施实现”有栈对称“的协程。

### 4.4 再谈协程的歹念

#### 4.4.1 简单协程与复合协程

![](../../blog/images/kotlin/kotlin-driveinto-coroutine-4.4.1-1.png)

#### 4.4.2 复合协程的实现模式

**协程的构造器**：我们总是需要一套更好更简便的API来创建协程，例如：`asyns{...}` 或 `Coroutine.create{...}`。

**协程的返回值**：协程可以有返回值，这一点主要有协程完成时对 completion 的调用来保证。

**协程的状态机**：在Kotlin协程的基础设施中，协程本身已经存在创建、执行、挂起、完成等状态了。符合协程的实现基本上就是明确事件输入和状态流转的过程。

**协程的作用域**：作用域主要用作协程体的 Receiver，从而令协程体能够方便的获得协程自身的信息或调用协程体专属的函数（例如：yield）。



## 第5章 Kotlin协程框架开发初探

### 5.2 协程的描述

#### 5.2.2 协程的状态

**Incomplete**：协程启动后立即进入该状态，直到完成或者被取消。

**Cancelling**：协程执行中被取消后进入该状态。进入该状态后，要等待协程体内部的挂起函数调用响应取消，响应后协程成功被取消抛出 CancellationException 取消，否则正常执行完成，两种情况都会调用完成回调的恢复调用将状态流转为 Complete，只是结果不同。

**Complete**：协程执行完成（包括正常返回和异常结束）时进入该状态。

### 5.4 协程的调度

#### 5.4.2 协程的调度位置

协程需要调度的位置就是挂起点的位置。当协程执行到挂起点的位置时，如果产生异步行为，协程就会在这个挂起点挂起。这里的异步情况可能包括一下几种形式：

- 挂起点对应的挂起函数内部切换了线程，并在该线程内部调用 Continuation 的恢复调用来恢复，例如通过OkHttp异步请求网络的情况，回调实际上是执行在OkHttp的IO线程上。
- 挂起函数内部通过某种事件的机制将 Continuation 的恢复调用转到新的线程调用栈上执行，例如在Android平台上也可以通过`Handler.post`函数来实现这样的操作。实际上这个过程中不一定发生线程切换。
- 挂起函数内部将 Continuation 实例保存，在后续某个时机再执行恢复调用，这个过程中不一定发生线程切换，但函数调用栈发生变化。

不管是任何形式，**恢复和挂起不在同一个函数调用栈中执行就是挂起点挂起的充分条件**，协程切换并不是必要条件。只有挂起点真正挂起，我们才有机会实现调度，而实现调度需要使用协程的拦截器。

#### 5.4.3 协程的调度器设计

调度的本质就是解决挂起点恢复之后的协程逻辑在哪里运行的问题。

#### 5.4.4 基于线程池的调度器

```kotlin
override fun dispatch(context: CoroutineContext, block: Runnable) {
        try {
            (pool ?: getOrCreatePoolSync()).execute(wrapTask(block))
        } catch (e: RejectedExecutionException) {
            unTrackTask()
            // CommonPool only rejects execution when it is being closed and this behavior is reserved
            // for testing purposes, so we don't have to worry about cancelling the affected Job here.
            DefaultExecutor.enqueue(block)
        }
    }
```

#### 5.4.5 基于UI事件循环的调度器

```kotlin
override fun dispatch(context: CoroutineContext, block: Runnable) {
        if (!handler.post(block)) {
            cancelOnRejection(context, block)
        }
    }
```

#### 5.4.6 为协程添加默认调度器



### 5.5 协程的取消

协程的取消本质上是**协作式取消**，这一点与线程的中断别无二致，即**自身状态需要置为取消，同时也需要协程体的执行逻辑能够检查状态的变化来响应取消**。



### 5.6 协程的异常处理



### 5.7 协程的作用域

#### 5.7.1 作用域的概念

官方框架在实现复合协程的郭恒汇总也提供了作用域，主要用以明确协程之间的父子关系，以及对取消或者异常处理等方面的传播行为。该作用域包括以下三种：

- **顶级作用域**：没有父协程的协程所在的作用域为顶级作用域。
- **协同作用域**：协程中启动新的协程，新携程为所在的协程的子协程，这种情况下子协程所在的作用域默认为协同作用域。此时子协程抛出的未捕获异常都将传递给父协程处理，父协程同时也会取消。
- **主从协程**：与协程作用域在协程的父子关系上一致，区别在于处于该作用域下的协程出现未捕获的异常时不会将异常向上传递给父协程。

除了这三种作用域中提到的行为外，父子协程之间还存在以下规则：

- 父协程被取消，则所有子协程均被取消。由于协同作用域和主从作用域中都存在父子协程关系，因此这条规则都适用。
- 父协程需要等待子协程执行完毕之后才会最终进入完成状态，不管父协程自身的协程体是否已经执行完。
- 子协程会继承父协程的上下文中的元素，如果自身有相同的`key`成员，则覆盖对应的`key`，覆盖的效果仅限自身范围内有效。



## 第6章 Kotlin协程的官方框架

### 6.1 协程框架概述

#### 6.1.1 框架的构成

Kotlin协程的官方框架`kotlin.coroutines`是一套独立于标准库之外的以生产为目的的框架，框架本身提供了丰富的API来支撑生产环境中异步程序的设计和实现。如图6-1所示，它主要由以下几部分构成。

![](../../blog/images/kotlin/kotlin-driveinto-coroutine-6.1.1-1.png)

- core：框架核心逻辑，包括 Channel、Flow 等特性。
- ui：包括 android、javafx、swing 三个库，用于提供各平台的UI调度器和一些特有的逻辑（如Android平台上的异常处理器设置）。
- reactive相关：提供对各种响应式编程框架的协程支持，包括如下几项。
- reactive：提供对Reative Streams（https://www.reactivestreams.org/）的协程支持。
- reactor：提供对Reactor（https://projoctreactor.io/）的协程支持，Spring的WebFlux就是基于Reactor实现的。
- rx2：提供对RxJava 2.x（https://github.com/RecictiveX/RxJava）版本的协程支持。
- integration：提供与其他框架的异步回调的集成，包括如下几项。
- jdk8：提供对CompletableFuture的协程API的支持。
- guava：提供对ListenableFuture的协程API的支持。
- slf4j：提供MDCContext作为协程上下文的元素，以使协程中使用slf4j打印日志时能够读取对应的MDC中的键值对。
- play-services：提供对Google Play服务中的Task的协程API的支持。

#### 6.1.2 协程的启动模式

- **DEFAULT**：协程创建后，立即开始调度，在调度钱如果协程被取消，其将直接进入取消响应的状态。
- **ATOMIC**：协程创建后，立即开始调度，协程执行到第一个挂起点之前不响应取消。
- **LAZY**：只有协程被取消时，包括主动调用协程的 start、join或await 等函数时才会开始调度，如果调度前就被取消，那么该协程将直接进入异常结束状态。
- **UNDISPATCHED**：协程创建后立即在当前函数调用栈中执行，直到遇到第一个真正挂起的点。

要搞清楚这几个模式的效果，需要先搞清楚**立即调度**和**立即执行**的区别。立即调度表示协程的调度器会立即接收调度指令，但具体执行的时机以及在哪个协程上执行，还需要根据调度器的具体情况而定，也就是说立即调度到立即执行之间通常会有一段时间。因此，可以得出以下结论：

- **DEFAULT**虽然是立即调度，但也有可能在执行前被取消。
- **UNDISPATCHED**是立即执行，因此协程一定会执行。
- **ATOMIC**虽然是立即调度，但其将调度和执行两个步骤合二为一了，就像它的名字一样，其保证调度和执行是原子操作，因此协程也一定会执行。
- **UNDISPATCHED**和**ATOMIC**虽然都会保证协程一定执行，但在第一个挂起点之前，前者运行在协程创建时所在的线程，后者则会调度到指定的调度器所在的线程上执行。

#### 6.1.3 协程的调度器

- **Default**：默认调度器，适合处理后台计算，其是一个CPU密集型任务调度器。
- **IO**：IO调度器，适合执行IO相关操作，其是一个IO密集型任务调度器。
- **Main**：UI调度器，根据平台不同会被初始化为对应的UI线程的调度器，例如在Android平台上它会将协程调度到UI事件循环中执行，即通常在主线程上执行。
- **Unconfined**：“无所谓”调度器，不要求协程执行在特定线程上。协程的调度器如果是Unconfined，那么它在挂起点恢复执行时会在恢复所在的线程上直接执行，当然，如果嵌套创建以它为调度器的协程，那么这些协程会在启动时被调度到协程框架内部的事件循环上，以避免出现StackOverfow。



### 6.2 热数据通道Channel

#### 6.2.1 认识Channel

Channel实际上就是一个并发安全的队列，它可以用来连接协程，实现不同协程的通信。
