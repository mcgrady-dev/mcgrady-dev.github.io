---
layout: article
title: Java并发编程
tags: java
---



<!--more-->



## 并发编程

在同一系统的多个进程有可能被交错运行，这些进程有同时执行与潜在交互的特性，因此有多个执行路径且结果可能具有不确定性，例如并发使用的共享资源可能变成一个不确定的资源并导致诸如死锁和资源匮乏的问题。

并发编程的三个核心：

- 分工：指的是如何高效地拆解任务并分配给线程；
- 同步：指线程间如何协作；
- 互斥：指保证同一时刻只允许一个线程访问共享的资源；



## 并发编程带来的问题

### 安全性问题

### 性能问题

#### 1 锁竞争

获取锁导致串行操作同时获取锁失败会导致线程挂起出现上下文竞争。

而在并发程序中，对可伸缩性的最主要威胁就是独占方式的资源锁。而影响锁竞争的因素：锁请求频率，每次持有锁的时间，如果两个的乘积很小，说明获取锁和持有锁的总时间就很少，那么大多数获取锁的操作都不会发生竞争。

#### 1.1 减少锁竞争的手段

减少锁竞争的主要方法是：减少锁的持有时间、降低锁的请求频次、或者使用带有协调机制的独占锁替代，因为这些机制允许更高的并发性。

- 缩小锁的范围：将于锁无关代码移除同步代码块，尤其是那些可能发生阻塞的I/O操作；
- 减少锁的粒度：使用多个互相独立锁管理独立的状态变量，改变某个变量只用获取对应变量锁，而不用获取整体锁，其他线程仍然能使用其他变量；
- 锁分段：比如ConcurrentHashMap对数组的每个元素进行加锁，即数组长度就是最大支持的并发数；
- 避免热点域：当一个操作要访问多个变量时，锁的粒度就很难减少了，一种解决方法是将这多个变量的计数结果缓存起来，都会引入一些“热点域”，这些热点域往往会限制可伸缩性；

#### 2 上下文切换

#### 2.2 减少线程的上下文切换

- JVM编译时优化：锁消除、锁粗化；
- `synchronized`：使用细粒度锁，本质上也是在减少锁持有的时间；
- 使用`volatile`+CAS的替代方案：`volatile`保证了可见性和有序性，并不会引起上下文的切换；
- 合理使用线程池：在处理CPU型任务时，并行度就是核心线程数，过多的线程只能增加线程上下文的切换；
- 减少GC中的*Stop The World*场景： GC工作线程会记录状态等，特别是在*Stop The World*时对业务本身影响最大；



#### 3. 内存同步

多线程开发在使用`synchronized`、`volatile`和`Lock`等保证资源可见性时，可能会使用一些特殊的指令内存栅栏（Memory Barrier），这些指令可以刷新缓存，同时会抑制一些编译器优化操作，例如不能指令重排，从而带来性能上的问题。



### 活跃性问题



### 并行与并发

并行（concurrent）是指两个或多个事件在同一时刻发生；并发（parallel）是指两个或多个事件在同一时间间隔内发生，但同一时间点，只有一个事件在执行。

![img](https://s2.loli.net/2022/09/22/L5GpYbUFWnTyAzO.jpg)



### synchronized

synchronized 采用互斥的方式让同一时刻至多只有一个线程能持有「对象锁」，其它线程再想获取这个「对象锁」时就会阻塞住。这样就能保证用友锁的线程可以安全的执行临界区的代码，不用担心代码上下文切换。



### 死锁

死锁：两个或以上的进程在执行过程中，由于竞争资源或彼此通信，进程间互相持有其他进程所需要的资源，而形成的一种头尾相接的循环等待资源关系，导致这一系列进程永远在互相等待。



### Copy on write

*Copy on write*简称COW，指写时复制，是一种优化策略，核心思想是多个调用者（callers）同时请求相同资源时，他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。





## 线程间同步

线程间同步的关键是避免共享资源的使用冲突，一般有以下几种同步方式：

### 互斥量（Mutex）

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，保证了公共资源同一时刻只有一个线程访问。Java中的synchronized和Lock使用的是这种机制。

### 信号量（Semaphore）

### 事件（Event）





## 线程安全





## IPC (Inter-Process Communication)

进程间通信指两个或多个进程或线程间传递数据或信号的一些技术和方法。





参考链接：

[不可不锁的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)

[Java锁比较全的入门整理](https://zhuanlan.zhihu.com/p/163864864)

