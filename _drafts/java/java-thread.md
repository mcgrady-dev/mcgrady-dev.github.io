## 线程

### 栈与栈帧

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

### 线程的上下文切换（Thread Context Switch）

发生线程切换的原因：

- 线程的 CPU 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程主动调用了 `sleep` `yield` `wait` `join` `park` `synchronized` `lock` 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程状态，并恢复另一个线程的状态，Java 中对应的概念就是 程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的。

>线程的状态包括：程序计数器、虚拟机栈中每个栈帧的信息。

Context Switch 频繁发生会影响性能



### 线程的状态

从操作系统层面的状态分类：

- 初始状态
- 可运行状态
- 阻塞状态
- 运行状态
- 终止状态

从 Java API 层面的状态分类：

- NEW
- RUNNABLE
- WAITING
- TIMED_WAITING
- TERMINATED
- BLOCKED



### 线程的常见方法

- sleep

- yield

- join
  等待线程运行结束

- interrupt

  打断线程

  - 如果线程处于 `sleep` `wait` `join` （阻塞状态），会导抛出 `InterruptedException`，并清空打断标记；
  - 如果线程正在运行，会设置打断标记但不会终止线程，可以通过 `isInterrupted()` 判断是否结束线程的执行；

- isInterrupted
  判断是否被打断，不会清除打断标记

- interrupted
  判断是否被打断，会清除打断标记



### 线程优先级

线程优先级会提示调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它；如果 cpu 比较忙，那么优先级高的线程会得到更多的时间片，但 cpu 闲时，优先级几乎没作用。

- MIN_PRIORITY：1
- NORM_PRIORITY：5
- MAX_PRIORITY：10



### ThreadLocal

#### 概述

线程局部变量，通过每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。

#### ThreadLocalMap

在 Therad 类中有一个 threadLocals 和 inheritableThreadLocals ，它们都是 ThreadLocalMap 类型的变量，而 ThreadLocalMap 是一个定制化的 HashMap 。

线程隔离的秘密，就在于 ThreadLocalMap 这个类。每个线程中都有一个独立的 ThreadLocalMap 副本，它所存储的值，只能被当前线程读取和修改。ThreadLocal 类通过操作每一个线程特有的 ThreadLocalMap 副本，从而实现了变量访问在不同线程中的隔离。因为每个线程的变量都是自己特有的，完全不会有并发错误。还有一点就是，ThreadLocalMap 存储的键值对中的键是 this 对象指向的 ThreadLocal 对象，而值就是你所设置的对象了。

#### ThreadLocal与同步机制的比较

ThreadLocal 和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。

在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。

而 ThreadLocal 则从另一个角度来解决多线程的并发访问。ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。**因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了**。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。

概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。





## 并行与并发

- 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
- 并行（parallel）是同一时间动手做（doing）多件事情的能力



## 同步与异步

- 同步：需要等待结果返回，才能继续运行
- 异步：不需要等待结果返回，就能继续运行



## 多线程

### 两阶段终止模式（Two Phase Termination）

在一个线程 T1 中如何“优雅”终止线程 T2 ？



### 主线程与守护线程

默认情况下，Java 进程需要等待所有与线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码还没执行完，也会强制结束。



## 共享模型之管程

### 共享带来的问题

上下文切换引起的指令交错导致了多线程访问共享资源的线程安全问题



解决方案

#### synchronized

synchronized 采用互斥的方式让同一时刻至多只有一个线程能持有「对象锁」，其它线程再想获取这个「对象锁」时就会阻塞住。这样就能保证用友锁的线程可以安全的执行临界区的代码，不用担心代码上下文切换。





## 非共享模型



## Monitor







