# Java 抽象类和接口

[TOC]

**抽象类和接口是java语言中对抽象类概念进行定义的两种机制**，正式由于他们的存在才赋予了java强大的面向对象的能力。他们两者之间对抽象概念的支持有很大的相似，甚至可以互换，但是也有区别。



## abstract 抽象类

在面向对象的领域一切都是对象，同时**所有的对象都是通过类来描述的，但并不是所有的类都是用来描述对象的**。

由于抽象的概念在问题领域没有对应的具体概念，所以**用以表示抽象概念的抽象类是不能实例化的**。

同时，**抽象类体现了数据抽象的思想，是实现多态的一种机制**。

同时，**抽象类提供了继承的概念**，它的出发点就是为了继承，否则它没有存在的任何意义。**所以定义的抽象类一定是用来继承的**，**在一个用以抽象类为节点的继承关系等级链中，叶子节点一定是具体的实现类**。

### 使用抽象类时需注意的几个点
1. 抽象类不能实例化，实例化的工作应该交由塔的子类来完成，它只需有一个引用即可。
2. 抽象方法必须由子类进行重写。
3. 只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含其他方法。
4. 抽象类中可以包含具体的方法，当然也可以不包含抽象方法。
5. 子类中抽象方法不能与父类抽象方法同名。
6. `abstract`不能与`final`并列修饰同一个类。
7. `abstract`不能与`private` `static` `final` `native` 并列修饰同一个方法。

### 实例
定义一个抽象动物类`Animal`，提供抽象方法`cry()`，`Cat` `Dog`都是动物类的子类，由于`cry()`为抽象方法，所以`Cat` `Dog` 必须实现`cry()`方法。如下：
```java
public abstract class Aniaml {
	public abstract void cry();
}

public class Cat extends Animal {
	@Override
	public void cry() {
	}
}

public class Dog extends Animal {
	@Override
	public void cry() {
	}
}

```

抽象类和抽象方法可以使类的抽象性明确起来，并告诉用户和编译器怎样使用它们，抽象类还是有有用的重构器，因为它们使我们可以很容易地将公共方法沿着继承层次结构向上移动。



## interface 接口
**接口本身不是类**，从我们不能实例化一个接口就可以看出。例如：错误的用法`new Runnable();`

**接口是用来建立类与类之间的协议，它提供的只是一种形式，而没有具体的实现**。同时实现该接口的实现类**必须要实现该接口的所有方法**，通过使用`implements`关键字使用。

通过实现一个接口的实现类，**表示该类在遵循某个或某组特定的接口，同时也声明它的工作规范**。

接口是抽象类的延伸，java为了保证数据安全是不能多重继承的。也就是说**继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口**，不管这些接口之间有没有关系。**所以接口弥补了抽象类不能多重继承的缺陷**，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。

### 使用接口时需注意的几个点
1. interface的所有方法访问权限自动被声明为`public`。
2. 接口中可以定义**成员变量**，或者说是不可变的常量，因为接口中的**成员变量**会自动变成`public static final`。可以通过类命名直接访问：`implements Class.name`
3. 接口中不存在实现的方法。
4. 实现接口的**非抽象类**必须要实现该接口的所有方法。抽象类可以不实现。
5. 不能使用`new`操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用一个实现该接口的类的对象。可以使用`instanceof`检查一个对象是否实现了某个特定的接口。
6. 在实现多接口的时候一定要避免方法名的重复。



## 抽象类与接口的区别
尽管抽象类和接口之间存在较大的相同点，甚至有时候还可以互换，但这样并不能弥补它们之间的差异之处。

下面将从语法层次和设计层次两个方面对抽象类和接口进行阐述：

### 语法层次
java对于抽象类和接口分别给出了不同的定义。
```java
public abstract class Demo {
	abstract void method1();
	
	void method2() {
		// 实现
	}	
}

interface Demo {
	void method1();
	void method2();
}
```

抽象类方式中，**抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法**；但是接口方式中，**它仅能够有静态、不能修改的成员数据**（但是我们一般是不会在接口中使用成员数据），**同时它所有的方法都必须是抽象的**。

### 设计层次

抽象类与接口存在的三个不同点：

**`抽象层次不同`**
**抽象类是对类抽象，而接口是对行为的抽象**。
抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。

**`跨域不同`**
抽象类所跨域的是具有相似特点的类，而接口却可以跨域不同的类。

**抽象类所体现的是一种继承关系**，要想使得继承关系合理，父类和派生类之间必须存在`is-a`关系，即**父类和派生类在概念本质上应该是相同的**。对于接口则不然，**并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已**。


**`设计层次的不同`**
**抽象类是自底向上抽象而来的，接口是自顶向下设计出来的**。
对于抽象类而言，它是自下而上来设计的，要先知道子类才能抽象出父类，但接口不同，它不需要知道子类的存在，只需定义一个规则即可。（比如说飞，我们不知道会有什么东西来实现这个飞接口，怎么实现也不得而知，我们要做的就是事前定义好飞的行为接口）

### 例子
```java
// 抽象类
abstract class Door {
	abstract void open();
	abstract void close();
	
	// 增加报警功能
	abstract void alarm();
}

// 接口
interface Door {
	void open();
	void close();

	// 增加报警功能
	void alarm();
}
```

以上这种方法违反了面向对象设计中的一个核心原则`ISP(Interface Segrega Principle)`[^Interface Segregation Principle]。

在Door的定义中把Door概念本身固有的行为方法和另外一个概念`报警器`的行为方法混乱在一起。

这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为`报警器`这个概念的改变而改变。

依据`ISP`原则将不同改的的模块分开定义在两个代表不同概念的抽象类里面，定义的方式有三种：
1. 两个都是用抽象类来定义 `X`
2. 两个都使用接口来定义
3. 一个使用抽象类定义，一个使用接口定义



1. 由于java不支持多继承所以第一种是不可行的。
2. 如果使用第二种定义，那么就反映了两个问题：
   1. 对问题域的错误理解：AlarmDoor在概念本质上到底是门还是报警器。
   2. 对问题域的理解：或者AlarmDoor在本质上概念是一致的，那么我们再设计时就没有正确的反映设计的意图。因为使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。
3. 对问题域的理解：AlarmDoor本质上是Door，对于这个概念使用抽象类来行医，但同时它拥有报警的行为功能，可以使用接口来进行定义。

#### 方案三
```java
abstract class Door {
	abstract void open();
	abstract void close();
}

interface Alarm {
	void alarm();
}

class AlarmDoor extends Door implements Alarm {
	void open(){}
	void close(){}
	void alarm(){}
}

```



## 总结
**抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口**。

**在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据**（不过一般都不在接口中定义成员数据），**而且它的所有方法都是抽象的**。

**抽象类和接口所反映的设计理念是不同的**，抽象类所代表的是`is-a`的关系，而接口所代表的是`like-a`的关系。

[^Interface Segregation Principle]: 面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。
一个类对另外一个类的依赖性应当是建立在最小的接口上的。
一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。

