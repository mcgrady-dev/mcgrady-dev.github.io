---
layout:
title: Java Memory Manager
date: 2017-02-07 08:49 +0800
tags: [java,jvm]
---



<!--more-->

## JVM内存结构

虚拟机在执行Java程序的过程中会把所管理的内存划分为若干个不同的数据区域，其中有些区域随着虚拟机进程的启动而存在，而有些区域则作为用户线程的启动和结束而建立和销毁。

Java内存区域指的是JVM的运行时数据分区，与Java内存模型是不同的两个概念。



## JMM内存模型

Java内存模型（Java Memory Model，JMM）是一种虚拟机规范，定义了 JVM 在计算机内存（RAM）中的工作方式，屏蔽了各种硬件和操作系统的内存访问差异，实现让 Java 程序在各平台上都能达到一致的并发效果。

Java内存模型是一个抽象的概念，是和多线程相关的，它描述了一组规则和规范，这个规范定义了**一个线程对共享变量的写入时对另一个线程是可见的**。







## 内存分配策略

一般内存粗糙的可以分为两块：
>*Java内存远比这个复杂，只是堆和栈是最重要的两块。*
### 堆（Heap）

**堆是内存中最大的一块，为线程共享，JVM启动时创建**。**主要用于存放`new`出来的对象以及数组**。而Java的垃圾回收机制管理的往往也就是这个堆内存，因此也成为GC（Grabage Collection Heap）堆。

> 此外还有方法区和常量池等内存区域。

- **Java Heap**
  在Android中，Java Heap 一般的大小上限是 16M 24M 48M 76M ，具体视手机而定。
- **Native Heap**
  Native Heap 是对于 C/C++ 直接操纵的系统堆内存，所以它的上限一般是具体的RAM的2/3左右。

### 栈（Stack）
栈，成为局部变量表，主要存储的是在非`static`的自动变量、函数参数、表达式的临时结果和函数返回值。**栈是线程私有的，生命周期与线程相同**。



## 自动垃圾回收机制

Java的垃圾回收机制最为Java语言的一大特性，**将Java堆空间内存的释放交给JVM自动处理**，无需开发人员在程序中显示调用，从而避免了因为开发人员忘记释放内存而造成的内存溢出。

其实Java自动垃圾回收主要做的事两件事：
- 内存回收
- 碎片清理

对于堆的管理，不同的语言实现的方式不同。
- **C**语言是通过库函数`malloc()`和`free()`来实现的。
- **C++**直接将对堆空间中对象的操作和分配释放到语言层次，使用`new`和`delete`语句。
- **Java**只需要开发人员在需要的时候创建就可以了，合适释放都由JVM来控制。而在Java的`Object`类中有一个`finalize()`方法，在垃圾回收期真正回收之前调用。



## java的内存分配策略

### 静态存储分配

指在编译时究竟能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给它们分配固定的内存空间空间。

### 栈式存储分配

在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但规定在运行中进入一个程序模块时，



## 堆式存储分配







**参考文献：**

[ 深入理解Java虚拟机 ](https://book.douban.com/subject/34907497/)
