---
layout: 
title: I/O 模型
date: 2022-04-27 15:22 +0800
tags: io
---

<!--more-->

## I/O 模型

### 阻塞 I/O 模型

进程发起I/O调用后，进程被阻塞，转到内核空间处理，整个I/O处理完毕后返回进程。

**典型应用**：

- 阻塞式Socket
- Java BIO

**特点**：

- 进程阻塞挂起不消耗CPU资源，及时响应每个操作
- 实现难度低、开发应用较容易
- 使用并发量小的网络应用开发

### 非阻塞 I/O 模型

进程发起IO系统调用后，如果内核缓冲区没有数据，需要到IO设备中读取，返回一个错误，以使得进程不被阻塞；进程发起IO系统调用后，如果内核缓冲区有数据，内核就会把数据返回进程。

**典型应用**：

- Socket（设置为NONBLOCK）

**特点**：

- 进程轮询调用，消耗CPU的资源
- 实现难度低、开发应用相对阻塞I/IO模式较难
- 适用并发量较小、且不需要及时响应的网络应用开发

### I/O 复用模型

多个进程的I/O注册到一个复用器（select）上，然后用一个进程调用该 select，select 会监听所有注册过来的I/O。

**典型应用**：

- Linux：select、poll、epoll
- Java：NIO

**特点**：

- 专一进程解决多个进程I/O的阻塞问题，性能好；Reactor设计模式
- 实现、开发应用难度较大
- 适用高并发服务应用开发：一个进程（线程）响应多个请求

### 信号驱动 I/O 模型

当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。

**特点**：回调机制，实现、开发应用难度大

### 异步 I/O 模型

前4种为同步I/O操作，只有异步I/O模型是异步I/O操作。

当进程发起一个I/O操作，进程返回（不阻塞），单也不能返回结果，内核会把整个I/O处理完后，会通知进程结果。

**典型应用**：Java7 AIO、高性能服务器应用

**特点**：

- 回调机制，不阻塞，数据一步到位；Proactor模式
- 需要操作系统的底层支持，Linux 2.5 版本内核首现，2.6版本产品的内核标准特性
- 实现、开发应用难度大
- 适合高性能并发应用

